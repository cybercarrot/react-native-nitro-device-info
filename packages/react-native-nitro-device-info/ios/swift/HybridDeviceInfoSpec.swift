///
/// HybridDeviceInfoSpec.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/// See ``HybridDeviceInfoSpec``
public protocol HybridDeviceInfoSpec_protocol: HybridObject {
  // Properties
  var deviceId: String { get }
  var brand: String { get }
  var model: String { get }
  var systemName: String { get }
  var systemVersion: String { get }
  var deviceType: DeviceType { get }
  var uniqueId: String { get }
  var manufacturer: String { get }
  var deviceName: String { get }
  var isTablet: Bool { get }
  var isEmulator: Bool { get }
  var deviceYearClass: Double { get }
  var isCameraPresent: Bool { get }
  var isPinOrFingerprintSet: Bool { get }
  var isHardwareKeyStoreAvailable: Bool { get }
  var isLowRamDevice: Bool { get }
  var isDisplayZoomed: Bool { get }
  var isLiquidGlassAvailable: Bool { get }
  var totalMemory: Double { get }
  var maxMemory: Double { get }
  var totalDiskCapacity: Double { get }
  var startupTime: Double { get }
  var version: String { get }
  var buildNumber: String { get }
  var bundleId: String { get }
  var applicationName: String { get }
  var readableVersion: String { get }
  var firstInstallTimeSync: Double { get }
  var lastUpdateTimeSync: Double { get }
  var carrierAllowsVOIP: Bool { get }
  var carrierIsoCountryCode: String { get }
  var mobileCountryCode: String { get }
  var mobileNetworkCode: String { get }
  var mobileNetworkOperator: String { get }
  var systemLanguage: String { get }
  var supportedAbis: [String] { get }
  var supported32BitAbis: [String] { get }
  var supported64BitAbis: [String] { get }
  var apiLevel: Double { get }
  var navigationMode: NavigationMode { get }
  var systemAvailableFeatures: [String] { get }
  var supportedMediaTypeList: [String] { get }
  var serialNumber: String { get }
  var androidId: String { get }
  var previewSdkInt: Double { get }
  var securityPatch: String { get }
  var codename: String { get }
  var incremental: String { get }
  var board: String { get }
  var bootloader: String { get }
  var device: String { get }
  var display: String { get }
  var fingerprint: String { get }
  var hardware: String { get }
  var host: String { get }
  var product: String { get }
  var tags: String { get }
  var type: String { get }
  var baseOs: String { get }
  var radioVersion: String { get }
  var buildId: String { get }
  var installerPackageName: String { get }
  var totalDiskCapacityOld: Double { get }
  var isMouseConnected: Bool { get }
  var isKeyboardConnected: Bool { get }
  var hostNames: [String] { get }
  var isTabletMode: Bool { get }

  // Methods
  func getHasNotch() throws -> Bool
  func getHasDynamicIsland() throws -> Bool
  func getIsLandscape() throws -> Bool
  func getBrightness() throws -> Double
  func getFontScale() throws -> Double
  func getUsedMemory() throws -> Double
  func getFreeDiskStorage() throws -> Double
  func getUptime() throws -> Double
  func getBatteryLevel() throws -> Double
  func getPowerState() throws -> PowerState
  func getIsBatteryCharging() throws -> Bool
  func isLowBatteryLevel(threshold: Double) throws -> Bool
  func getFirstInstallTime() throws -> Promise<Double>
  func getLastUpdateTime() throws -> Promise<Double>
  func getIpAddress() throws -> Promise<String>
  func getIpAddressSync() throws -> String
  func getMacAddress() throws -> Promise<String>
  func getMacAddressSync() throws -> String
  func getUserAgent() throws -> Promise<String>
  func getIsAirplaneMode() throws -> Bool
  func getCarrier() throws -> Promise<String>
  func getCarrierSync() throws -> String
  func isHeadphonesConnected() throws -> Promise<Bool>
  func getIsHeadphonesConnected() throws -> Bool
  func getIsWiredHeadphonesConnected() throws -> Bool
  func getIsBluetoothHeadphonesConnected() throws -> Bool
  func isLocationEnabled() throws -> Promise<Bool>
  func getIsLocationEnabled() throws -> Bool
  func getAvailableLocationProviders() throws -> [String]
  func getHasGms() throws -> Bool
  func getHasHms() throws -> Bool
  func hasSystemFeature(feature: String) throws -> Bool
  func getDeviceToken() throws -> Promise<String>
  func syncUniqueId() throws -> Promise<String>
  func getInstallReferrer() throws -> Promise<String>
  func isSideLoadingEnabled() throws -> Bool
  func getFreeDiskStorageOld() throws -> Double
  func isDeviceCompromised() throws -> Bool
  func verifyDeviceIntegrity() throws -> Promise<Bool>
}

public extension HybridDeviceInfoSpec_protocol {
  /// Default implementation of ``HybridObject.toString``
  func toString() -> String {
    return "[HybridObject DeviceInfo]"
  }
}

/// See ``HybridDeviceInfoSpec``
open class HybridDeviceInfoSpec_base {
  private weak var cxxWrapper: HybridDeviceInfoSpec_cxx? = nil
  public init() { }
  public func getCxxWrapper() -> HybridDeviceInfoSpec_cxx {
  #if DEBUG
    guard self is HybridDeviceInfoSpec else {
      fatalError("`self` is not a `HybridDeviceInfoSpec`! Did you accidentally inherit from `HybridDeviceInfoSpec_base` instead of `HybridDeviceInfoSpec`?")
    }
  #endif
    if let cxxWrapper = self.cxxWrapper {
      return cxxWrapper
    } else {
      let cxxWrapper = HybridDeviceInfoSpec_cxx(self as! HybridDeviceInfoSpec)
      self.cxxWrapper = cxxWrapper
      return cxxWrapper
    }
  }
}

/**
 * A Swift base-protocol representing the DeviceInfo HybridObject.
 * Implement this protocol to create Swift-based instances of DeviceInfo.
 * ```swift
 * class HybridDeviceInfo : HybridDeviceInfoSpec {
 *   // ...
 * }
 * ```
 */
public typealias HybridDeviceInfoSpec = HybridDeviceInfoSpec_protocol & HybridDeviceInfoSpec_base
